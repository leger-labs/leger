#!/usr/libexec/bluebuild/nu/nu

const configPath = "/usr/share/bluebuild/quadlets/configuration.yaml"

def main [] {
    print "BlueBuild Quadlets Manager - Podman Quadlet Management"
    print ""
    print $"(antml:underline)(antml:bold)Usage:(ansi reset) bluebuild-quadlets-manager [command] <args>"
    print ""
    print $"(antml:underline)(antml:bold)Information Commands:(ansi reset)"
    print $"    (antml:bold)show(ansi reset)                    Show all configured quadlets and their sources"
    print $"    (antml:bold)list(ansi reset)                    List installed quadlets"
    print $"    (antml:bold)status [name](ansi reset)           Show systemd service status for a quadlet"
    print $"    (antml:bold)logs [name] [--lines N](ansi reset) View logs for a quadlet's services"
    print $"    (antml:bold)inspect [name](ansi reset)          Detailed inspection of a quadlet"
    print ""
    print $"(antml:underline)(antml:bold)Update Commands:(ansi reset)"
    print $"    (antml:bold)update [name|all](ansi reset)       Update quadlet(s) from Git sources (direct)"
    print $"    (antml:bold)stage [name|all](ansi reset)        Download updates without applying (safe)"
    print $"    (antml:bold)apply [name|all](ansi reset)        Apply previously staged updates"
    print $"    (antml:bold)diff [name](ansi reset)             Show differences between current and staged"
    print $"    (antml:bold)staged(ansi reset)                  List all staged updates"
    print $"    (antml:bold)discard [name|all](ansi reset)      Discard staged updates"
    print ""
    print $"(antml:underline)(antml:bold)Backup & Restore:(ansi reset)"
    print $"    (antml:bold)backup [name|all](ansi reset)       Create backup of quadlet(s) and volumes"
    print $"    (antml:bold)restore [name] [id](ansi reset)     Restore from backup"
    print $"    (antml:bold)backups [name](ansi reset)          List available backups"
    print ""
    print $"(antml:underline)(antml:bold)Management:(ansi reset)"
    print $"    (antml:bold)discover(ansi reset)                Discover externally-managed quadlets"
    print $"    (antml:bold)validate [name](ansi reset)         Validate quadlet configuration"
    print $"    (antml:bold)enable updates(ansi reset)          Enable automatic updates"
    print $"    (antml:bold)disable updates(ansi reset)         Disable automatic updates"
    print $"    (antml:bold)check-conflicts [name](ansi reset)  Check for port/volume conflicts"
    print ""
    print $"(antml:underline)(antml:bold)Examples:(ansi reset)"
    print $"    (ansi default_italic)bluebuild-quadlets-manager stage all(ansi reset)         # Stage all updates for review"
    print $"    (ansi default_italic)bluebuild-quadlets-manager diff ai-stack(ansi reset)     # See what changed"
    print $"    (ansi default_italic)bluebuild-quadlets-manager apply ai-stack(ansi reset)    # Apply the update"
    print $"    (ansi default_italic)bluebuild-quadlets-manager backup all(ansi reset)        # Backup before updates"
}

def "main update" [target: string = "all"] {
    print $"(ansi yellow)Direct update - consider using 'stage' first for safer updates(ansi reset)"
    print ""
    
    if not ($configPath | path exists) {
        print $"(ansi red)No configuration found(ansi reset)"
        exit 1
    }
    
    let config = (open $configPath)
    
    if $target == "all" {
        print "Updating all quadlets..."
        /usr/libexec/bluebuild/quadlets/user-quadlets-update
        /usr/libexec/bluebuild/quadlets/system-quadlets-update
    } else {
        let quadlet = ($config.configurations | where name == $target | first)
        
        if ($quadlet | is-empty) {
            print $"(ansi red)Quadlet not found: ($target)(ansi reset)"
            exit 1
        }
        
        if $quadlet.scope == "user" {
            print "Updating user quadlet..."
            /usr/libexec/bluebuild/quadlets/user-quadlets-update $target
        } else {
            print "Updating system quadlet..."
            /usr/libexec/bluebuild/quadlets/system-quadlets-update $target
        }
    }
}

def "main stage" [...args] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu stage ...$args
}

def "main apply" [...args] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu apply ...$args
}

def "main diff" [name: string] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu diff $name
}

def "main staged" [] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu list
}

def "main discard" [...args] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu discard ...$args
}

def "main backup" [...args] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu backup ...$args
}

def "main restore" [...args] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu restore ...$args
}

def "main backups" [...args] {
    nu /usr/share/bluebuild/quadlets/../staged-updates.nu list-backups ...$args
}

def "main discover" [] {
    print "Discovering externally-managed quadlets..."
    /usr/libexec/bluebuild/quadlets/user-quadlets-setup
    /usr/libexec/bluebuild/quadlets/system-quadlets-setup
}

def "main validate" [name: string] {
    let userPath = $"($env.HOME)/.config/containers/systemd/($name)"
    let systemPath = $"/etc/containers/systemd/($name)"
    
    mut quadletPath = ""
    
    if ($userPath | path exists) {
        $quadletPath = $userPath
    } else if ($systemPath | path exists) {
        $quadletPath = $systemPath
    } else {
        print $"(ansi red)Quadlet not found: ($name)(ansi reset)"
        exit 1
    }
    
    print $"Validating quadlet: (antml:bold)($name)(ansi reset)"
    
    # Basic validation
    let files = (ls $quadletPath | where type == file)
    
    for file in $files {
        let fileName = ($file.name | path basename)
        let ext = ($fileName | path parse | get extension)
        
        if $ext in [".container" ".pod" ".network" ".volume" ".kube"] {
            print $"  (ansi green)✓(ansi reset) ($fileName)"
        }
    }
    
    print ""
    print $"(ansi green)Validation complete(ansi reset)"
    print $"(ansi blue)Tip:(ansi reset) Use 'inspect' for detailed analysis"
}

def "main check-conflicts" [name: string = ""] {
    if ($name | is-empty) {
        print "Checking all quadlets for conflicts..."
        # Check all installed quadlets
        let userPath = $"($env.HOME)/.config/containers/systemd"
        if ($userPath | path exists) {
            let userQuadlets = (ls $userPath | where type == dir | get name | each {|p| $p | path basename})
            for quadlet in $userQuadlets {
                checkQuadletConflicts $quadlet "user"
            }
        }
    } else {
        checkQuadletConflicts $name ""
    }
}

def "main enable" [what: string] {
    if $what != "updates" {
        print $"(ansi red)Unknown option: ($what)(ansi reset)"
        print "Usage: bluebuild-quadlets-manager enable updates"
        exit 1
    }
    
    print "Enabling automatic updates..."
    systemctl enable --now system-quadlets-update.timer
    systemctl enable --now --global user-quadlets-update.timer
    print $"(ansi green)✓(ansi reset) Automatic updates enabled"
}

def "main disable" [what: string] {
    if $what != "updates" {
        print $"(ansi red)Unknown option: ($what)(ansi reset)"
        print "Usage: bluebuild-quadlets-manager disable updates"
        exit 1
    }
    
    print "Disabling automatic updates..."
    systemctl disable --now system-quadlets-update.timer
    systemctl disable --now --global user-quadlets-update.timer
    print $"(ansi green)✓(ansi reset) Automatic updates disabled"
}

# Helper functions

def getServiceStatus [name: string, scope: string] {
    let quadletPath = if $scope == "user" {
        $"($env.HOME)/.config/containers/systemd/($name)"
    } else {
        $"/etc/containers/systemd/($name)"
    }
    
    if not ($quadletPath | path exists) {
        return { active: false, state: "not-found" }
    }
    
    let containerFiles = (ls $quadletPath | where name =~ "\.container$")
    if ($containerFiles | is-empty) {
        return { active: false, state: "no-containers" }
    }
    
    let fileName = ($containerFiles | first | get name | path basename)
    let serviceName = ($fileName | str replace ".container" ".service")
    
    let statusCmd = if $scope == "user" {
        $"systemctl --user is-active ($serviceName)"
    } else {
        $"systemctl is-active ($serviceName)"
    }
    
    let result = (do -i { bash -c $statusCmd } | complete)
    let state = ($result.stdout | str trim)
    
    { 
        active: ($state == "active")
        state: $state
    }
}

def extractPorts [quadletPath: string] {
    let files = (ls $quadletPath | where name =~ "\.container$|\.pod$")
    
    mut ports = []
    
    for file in $files {
        let content = (open $file.name)
        let lines = ($content | lines | where {|line| $line | str contains "PublishPort="})
        
        for line in $lines {
            let port = ($line | str replace "PublishPort=" "" | str trim)
            let parts = ($port | split row ":")
            
            if ($parts | length) >= 2 {
                $ports = ($ports | append {
                    host: ($parts | first)
                    container: ($parts | get 1 | split row "/" | first)
                    protocol: (if ($parts | get 1 | str contains "/") { 
                        $parts | get 1 | split row "/" | get 1 
                    } else { 
                        "tcp" 
                    })
                })
            }
        }
    }
    
    $ports
}

def extractVolumes [quadletPath: string] {
    let files = (ls $quadletPath | where name =~ "\.container$")
    
    mut volumes = []
    
    for file in $files {
        let content = (open $file.name)
        let lines = ($content | lines | where {|line| $line | str contains "Volume="})
        
        for line in $lines {
            let vol = ($line | str replace "Volume=" "" | str trim)
            $volumes = ($volumes | append ($vol | split row ":" | first))
        }
    }
    
    $volumes
}

def extractNetworks [quadletPath: string] {
    let files = (ls $quadletPath | where name =~ "\.container$")
    
    mut networks = []
    
    for file in $files {
        let content = (open $file.name)
        let lines = ($content | lines | where {|line| $line | str contains "Network="})
        
        for line in $lines {
            $networks = ($networks | append ($line | str replace "Network=" "" | str trim))
        }
    }
    
    $networks
}

def checkQuadletConflicts [name: string, scope: string] {
    print $"Checking ($name) for conflicts..."
    
    let quadletPath = if ($scope == "user") or ($scope == "") {
        $"($env.HOME)/.config/containers/systemd/($name)"
    } else {
        $"/etc/containers/systemd/($name)"
    }
    
    if not ($quadletPath | path exists) {
        print $"  (ansi yellow)Not found(ansi reset)"
        return
    }
    
    let ports = (extractPorts $quadletPath)
    let systemPorts = (do -i { ss -tlnp } | complete | get stdout | lines)
    
    mut hasConflicts = false
    
    for port in $ports {
        let hostPort = $port.host
        let inUse = ($systemPorts | any {|line| $line | str contains $":($hostPort)" })
        
        if $inUse {
            print $"  (ansi red)✗(ansi reset) Port ($hostPort) is already in use"
            $hasConflicts = true
        }
    }
    
    if not $hasConflicts {
        print $"  (ansi green)✓(ansi reset) No conflicts detected"
    }
}
